# 互联网协议入门

### **一、概述**

**1.1 五层模型**

互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。

用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。

如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052902.png)

如上图所示，最底下的一层叫做"实体层"（Physical Layer），最上面的一层叫做"应用层"（Application Layer），中间的三层（自下而上）分别是"链接层"（Link Layer）、"网络层"（Network Layer）和"传输层"（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。

它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。

**1.2 层与协议**

每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。

大家都遵守的规则，就叫做"协议"（protocol）。

互联网的每一层，都定义了很多协议。这些协议的总称，就叫做"互联网协议"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。

### **二、实体层**

我们从最底下的一层开始。

电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052903.png)

**这就叫做"实体层"，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。**

### **三、链接层**

**3.1 定义**

单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？

**这就是"链接层"的功能，它在"实体层"的上方，确定了0和1的分组方式。**

**3.2 以太网协议**

早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做["以太网"](http://zh.wikipedia.org/wiki/以太网)（Ethernet）的协议，占据了主导地位。

以太网规定，一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052904.png)

"标头"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；"数据"则是数据包的具体内容。

"标头"的长度，固定为18字节。"数据"的长度，最短为46字节，最长为1500字节。因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。

**3.3 MAC地址**

上面提到，以太网数据包的"标头"，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？

以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052905.jpg)

每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052906.png)

前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。

**3.4 广播**

定义地址只是第一步，后面还有更多的步骤。

首先，一块网卡怎么会知道另一块网卡的MAC地址？

回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。

其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？

回答是以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052907.png)

上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的"标头"，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做"广播"（broadcasting）。

有了数据包的定义、网卡的MAC地址、广播的发送方式，"链接层"就可以在多台计算机之间传送数据了。

### **四、网络层**

**4.1 网络层的由来**

以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。

但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一"包"，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。

互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052914.png)

因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用"路由"方式发送。（"路由"的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。

**这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"。**

于是，"网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。

网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。

**4.2 IP协议**

规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。

目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052908.png)

习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。

互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。

但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。

那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数"子网掩码"（subnet mask）。

所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。

知道"子网掩码"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。

比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。

总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。

**4.3 IP数据包**

根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。

但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？

回答是不需要，我们可以把IP数据包直接放进以太网数据包的"数据"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。

具体来说，IP数据包也分为"标头"和"数据"两个部分。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052909.png)

"标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052910.png)

IP数据包的"标头"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的"数据"部分，最长为65,515字节。前面说过，以太网数据包的"数据"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。

**4.4 ARP协议**

关于"网络层"，还有最后一点需要说明。

因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。

所以，我们需要一种机制，能够从IP地址得到MAC地址。

这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。

第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。

总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。

### **五、传输层**

**5.1 传输层的由来**

有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。

接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？

也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做"端口"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

"端口"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。

**"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。**因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。

**5.2 UDP协议**

现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。

UDP数据包，也是由"标头"和"数据"两部分组成。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052911.png)

"标头"部分主要定义了发出端口和接收端口，"数据"部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的"数据"部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052912.png)

UDP数据包非常简单，"标头"部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。

**5.3 TCP协议**

UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。

为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。

因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。

TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。

### **六、应用层**

应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。

**"应用层"的作用，就是规定应用程序的数据格式。**

举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。

这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分。因此，现在的以太网的数据包就变成下面这样。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052913.png)

至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。

### **七、小结**

先对前面的内容，做一个小结。

我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052913.png)

发送这个包，需要知道两个地址：

> 　　* 对方的MAC地址
>
> 　　* 对方的IP地址

有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061101.jpg)

上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。

1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：

| 场景           | 数据包地址                  |
| -------------- | --------------------------- |
| 同一个子网络   | 对方的MAC地址，对方的IP地址 |
| 非同一个子网络 | 网关的MAC地址，对方的IP地址 |

发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。

### **八、上网设置**

**8.1 静态IP地址**

你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061110.jpg)

通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：

> 　　* 本机的IP地址
> 　　* 子网掩码
> 　　* 网关的IP地址
> 　　* DNS的IP地址

下图是Windows系统的设置窗口。

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061111.png)

这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作"静态IP地址上网"。

但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用"动态IP地址上网"。

**8.2 动态IP地址**

所谓"动态IP地址"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做[DHCP协议](http://zh.wikipedia.org/zh/DHCP)。

这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数。

前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？

DHCP协议做了一些巧妙的规定。

**8.3 DHCP协议**

首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061102.png)

　　（1）最前面的"以太网标头"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。

　　（2）后面的"IP标头"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。

　　（3）最后的"UDP标头"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。

这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包。

接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个"DHCP响应"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。

新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。

**8.4 上网设置：小结**

这个部分，需要记住的就是一点：不管是"静态IP地址"还是"动态IP地址"，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：

> 　　* 本机的IP地址
> 　　* 子网掩码
> 　　* 网关的IP地址
> 　　* DNS的IP地址

有了这几个数值，电脑就可以上网"冲浪"了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。

### **九、访问网页**

**9.1 本机参数**

我们假定，经过上一节的步骤，用户设置好了自己的网络参数：

> 　　* 本机的IP地址：192.168.1.100
> 　　* 子网掩码：255.255.255.0
> 　　* 网关的IP地址：192.168.1.1
> 　　* DNS的IP地址：8.8.8.8

然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061103.png)

这意味着，浏览器要向Google发送一个网页请求的数据包。

**9.2 DNS协议**

我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。

[DNS协议](http://en.wikipedia.org/wiki/Domain_Name_System)可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061105.png)

然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。

**9.3 子网掩码**

接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。

已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。

因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。

**9.4 应用层协议**

浏览网页用的是HTTP协议，它的整个数据包构造是这样的：

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061106.png)

HTTP部分的内容，类似于下面这样：

> 　　GET / HTTP/1.1
> 　　Host: www.google.com
> 　　Connection: keep-alive
> 　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ......
> 　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
> 　　Accept-Encoding: gzip,deflate,sdch
> 　　Accept-Language: zh-CN,zh;q=0.8
> 　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
> 　　Cookie: ... ...

我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。

**9.5 TCP协议**

TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。

TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。

**9.6 IP协议**

然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。

IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。

**9.7 以太网协议**

最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。

以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061107.png)

**9.8 服务器端响应**

经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。

根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的"HTTP请求"，接着做出"HTTP响应"，再用TCP协议发回来。

本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061104.jpg)

这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。



#**网络协议及层次关系**

<img src="/Users/houshaojie/Library/Application Support/typora-user-images/image-20200423153850855.png" alt="image-20200423153850855" style="zoom:50%;" />

### **1、 进程/应用层的协议**

​	平时最广泛的协议，这一层的每个协议都由客程序和服务程序两部分组成。程序通过服务器与客户机交互来工作。常见协议有：Telnet、FTP、SMTP、HTTP、DNS等。

**TELNET** Protocol 虚拟终端协议

**SMTP** (Simple Mail Transfer Protocol) 简单邮件传送协议

**DNS** 域名解析协议 [www.baidu.com](http://www.baidu.com)

**FTP** (File Transfer Protocol) 文件传输协议，它是一个标准协议，是在计算机和网络之间交换文件的最简单方法

**TFTP** (Trivial File Transfer Protocol) 小文件传输协议

**HTTP** (Hyoertext Transfer Protocol) 超文本传输协议

**HTTPS** (Secure Hypertext Transfer Protocol) 安全超文本传输协议，它由Netscape开发并内置与浏览器中，用于对数据进行压缩和解压操作

### **2、 主机—主机层协议**

建立并且维护连接，用于保证主机间数据传输的安全性。这一层主要有两个协议：

**TCP**（Transmission Control Protocol：传输控制协议；面向连接，可靠基于字节流的传输层通信协议 tcp(三次握手和四次挥手)

**UDP**（User Datagram Protocol）：用户数据报协议；面向无连接，不可靠传输 用来在互联网络环境中提供包交换的计算机通信的协议

**总结：TCP与UDP的区别**

​         **1. TCP基于连接更可靠，UDP是 无连接**

​         **2  对系统资源的要求(TCP较多，UDP少)**	

​         **3  UDP程序结构简单；UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节，节省很多网络开销，所以传输速度更快**

​         **4  TCP保证数据正确性，UDP可能丢包；TCP保证数据顺序，UDP不保证**

**场景：视频，语音通讯使用UDP，或网络环境很好，局域网内通讯可以使用UDP。UDP数据传输完整性，可以通过应用层的软件来校对就可以了。**

​             **UDP不需要给我确认，我就一直给你发  现在的DDOS攻击--UDP洪水攻击**

​            **TCP传文件，数据完整性要求高。**

### **3、 Internet网络层协议**

​	负责数据的传输，在不同网络和系统间寻找路由，分段和重组数据报文，另外还有设备寻址。些层包括如下协议：

**IP**（Internet Protocol）:Internet协议，负责TCP/IP主机间提供数据报服务，进行数据封装并产生协议头，TCP与UDP协议的基础。

**ARP** (Address Resolution Protocol) 地址解析协议，将IP解析成MAC地址    ARP高速缓存表的条目分为 动态条目和静态条目

​           静态条目是由用户使用ARP命令行工具手动添加的IP地址和MAC地址的对应关系

​           动态条目是自动添加的，当网络设备向网络中发送一个广播信息，询问到某个设备的MAC地址得到回应后添加的。不是永久性的，而是会定期刷新

**ICMP** (Internet Control Message Protocol) I**nternet控制报文协议。ICMP协议其实是IP协议的的附属协议，IP协议用它来与其它主机或路由器交换错误报文和其它的一些网络情况，在ICMP包中携带了控制信息和故障恢复信息**。**ping** ip定义消息类型有：TTL超时、地址的请求与应答、信息的请求与应答、目的地不可到达

​      **TTL**  Time to Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPV4包头的一个8 bit字段

**RARP**（Reverse Address Resolution Protocol）：逆向地址解析协议。

**SNMP** (Simple Network Management Protocol) 简单网络管理协议

**DHCP** (Dynamic Host Configuration Protocol) 动态主机配置协议，它是在TCP/IP网络上使客户机获得配置信息的协议

   

#从 URL 到网页通信原理

互联网的原始目的，就是为了传输文本（文本对话）。那我们使用浏览器发送请求后页面是如何呈现在我们面前的呢？ 接下来由图片介绍下URL到呈现页面的过程。

## 一、文本对话--从请求到响应

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHlja1h2bnkwS2pObmliREdqd3VjUThEQkdqVWtRT0pKd3JTT3BVamh4NkJPZjN5eG5BM0lpYUxqc1EvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png)

客户端（浏览器）请求过程.jpg

我们在浏览器中输入一个 URL，回车之后便会在浏览器中观察到页面内容。实际上这个过程是：

（1）浏览器向网站所在的服务器发送了一个 Request（请求）

（2）网站服务器接收到这个Request之后进行处理和解析

（3）然后返回对应的一个Response（响应）给浏览器，Response里面就包含了页面的源代码等内容

（4）浏览器再对其进行解析便将网页呈现了出来。

这个文本对话的过程是建立在怎样的规则上面呢？简单说，**这个通信的过程是基于TCP/IP通信协议族规范上实现的**，完成从客户端到服务器端等一系列信息交换的流程。

## 二、TCP/IP 协议族介绍

### 1、TCP/IP协议族是什么呢？

TCP/IP协议族的目的就是通过建立规则使计算机之间可以进行信息交换。

相互通信的双方就必须基于相同的方法，比如由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定，我们就把这种规则称为协议（protocol）。通常我们说的TCP/IP协议族是互联网相关的各类协议族的总称。

![TCP/IP协议族](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljVDJQRnZUcktubkVEaWMwd2EyVVRPUWFXWkNUNGd0WVh1ZWljR3JGOWxLelB0anlqdFhjMWZodUEvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png)

TCP/IP协议族

TCP/IP协议族由那么多的协议组成，那功能上如何划分的呢？

这里就说到TCP/IP重要的层次化划分，按层次可以分为4层：**应用层、传输层、网络层和链路层**。（层次化的好处在于每个层次内部的设计可以自由改动，并通过各层的接口关联起来，而如果只有一个协议统筹就需要对所有涉及到的部分都重新设计。）

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljSzZyY3BMTVJYNlhJMVhORXdmbjdRZ1NURk9pYVF4dnlNcjN1ekd1eUlLa1JwUkUxVGJVYUtnZy82NDA_d3hfZm10PWpwZWc?x-oss-process=image/format,png)

应用层、传输层、网络层和链路层

### 2、TCP/IP各功能层的作用

（1） **应用层**：决定了向用户提供应用服务时候的通信活动。应用层负责传送各种最终形态的数据，是直接与用户打交道的层，典型协议是HTTP、FTP等。

（2） **传输层**：负责传送文本数据。传输层有两个性质不同的协议： TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。

![TCP UDP](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljTXVGRGZHZFluVFBIb3NMSFYxbFZKbzB4dUZCcVN2Q0FsNDJwMllzaldwZVM2RDNWU05Ba3N3LzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png)

（3） **网络层**：负责分配地址和传送二进制数据，主要协议是IP协议；

（4） **链路层**：负责建立电路连接，是整个网络的物理基础，典型的协议包括以太网、ADSL等。

### 3、TCP/IP 通信传输流

在TCP/IP各功能层之间数据是如何流动传输的呢？

![通信传输流](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljeDhtbmFZbEJxRkZXekNwQ3FHT0E1ajE0UmlhVHdjN3FpY29wQ1o2YnBieFhxQ0hpYllyYlpoMXBnLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png)

通信传输流

（1）首先作为发送端的客户端在应用层（HTTP 协议）发出的 HTTP请求（如：想浏览www.baidu.com），并生成HTTP报文。

（2）为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在 各个报文上打上标记序号及端口号后转发给网络层。

（3）在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。

（4）给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。

（5）接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。

在通信过程每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。

## 三、基于TCP/IP通信过程

一张图来说明请求到网页呈现的通信过程（ 下图基于IP 协议、TCP 协议 、DNS 服务和HTTP 协议的通信过程），并对每一步做说明：

![通信过程.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljVldkaWNIUk5Ram5FOWJmOWxiTks5TWszQ2ZQVkhoajNtb2ljQ250V0tmN1V0WkVad3FLUzU3WkEvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png)

通信过程.png

### 1、浏览器输入URL发送请求

URL（Uniform Resource Locator，统一资源定位符），是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。

![url](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljTk9zVm5pYmxmNG1iYmxXMms3cjJHTE5MU2VrNWV6dTUxVm8xRWRPeGV5Tm5FNk5iYW1KUXVNQS82NDA_d3hfZm10PWpwZWc?x-oss-process=image/format,png)

url

URL由以下元素组成：

![URL格式介绍.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljeWF3S0JOQlRlclU3bjB0cUxpYWZQVm5pYks5OUlRUnZEcE9XaEJzazF5QkJtWFV5WWNQMm9KN0EvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png)

URL格式介绍.png

（1） 传送协议：http:或者https:等

（2） 层级URL标记符号：为“//”固定不变

（3） 登录信息： 访问资源需要的凭证信息（可省略）

（4） 服务器地址：通常为域名，有时为IP地址（实际通信中需要通过IP地址访问，域名通过DNS服务器解析出IP地址）

（5） 端口号：以数字方式表示，若为HTTP的默认值“:80”可省略

（6） 路径：以“/”字符区别路径中的每一个目录名称

（7） 查询：GET模式的窗体参数，以“?”字符为起点，每个参数以“&”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题

（8） 片段：以“#”字符为起点，使用片段标识符通常可标记出已获取资源中的子资源

### 2、DNS对请求中的URL域名解析

![DNS协议.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljSVBqdWVlUmFmQjRBTm9wNVdCSm80a25hb0hzNGU4ZFdrQ0YxZEtpYVhsTE5PV2p3aEhLUjRVZy82NDA_d3hfZm10PWpwZWc?x-oss-process=image/format,png)

DNS协议.png

DNS（Domain Name System）服务是和 HTTP协议一样位于应用层的协议，它提供域名到 IP 地址之间的解析服务。

计算机既可以被赋予IP地址，也可以被赋予主机名和域名，用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。而计算机相对更容易处理一组数字，这时DNS域名解析服务应运而生。DNS 协议提供通过域名查找 IP 地址（或逆向从 IP 地址反查域名的服务）。

### 3、HTTP协议生成请求报文

HTTP协议：HyperText Transfer Protocol超文本传输协议位于应用层，决定从客户端到服务器端等一系列通信内容及方式，这通过生成报文并发送完成通信。

![HTTP协议](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljbUNqMnFFMGliSDhpY3BQaDBwWEMzclJRaWFsSmljS3VpY3VueUVYdmFNY1dabkFXNmt0U2liOWljRTBPdy82NDA_d3hfZm10PWpwZWc?x-oss-process=image/format,png)

HTTP协议

（1）请求报文的构成

![请求报文](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljaWE1OGlhMTVqQWFvYXlpY2dPaWFlZ0dGczIzaWJpYjU4SUJLaWJ0a1dYWXc4cFlIdHozTnppYmlhYmJER0FnLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png)

请求报文

（2）响应报文的构成

![响应报文](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljUWVNTnVJZ29BVGFPZ3VYTnVQdkFpYXBLMXBBQkRlTHRJMUE5NGljcWtEQWNDSEU2YzI5MndKRkEvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png)

响应报文

### 4、TCP协议提供可靠的字节流传输服务

TCP协议：Transmission Control Protocol传输控制协议，位于传输层。

（1）字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment） 为单位的数据包进行管理。

（2）可靠的传输服务是指，能够把数据准确可靠地传给对方。TCP 协议采用了三次握手连接等策略保证传输的可靠性（三次握手，四次挥手文末会有重点补充）

![3次握手.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljb051RHRyZVdIelI5RHRHekhzV05HWU00SEc2V2s5OXAxT1B1d0Z6bXdWWDlFZm1KS0lUZEd3LzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png)

3次握手.png

### 5、IP协议实现数据传递到对方计算机

IP（Internet Protocol）网际协议位于网络层。 IP协议的作用在于实现数据包传递到对方计算机IP地址。而IP间的通信依赖于MAC 地址（网卡所属的固定地址），还需要再通过ARP 协议根据通信方的 IP 地址反查出对应的MAC 地址。

![IP协议.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljeHpXcWc4OHRYSzlWelhFek1mRmVBVU9ZNGZUcjI1UGVyM3ZjOGVBaWNFYjBaY2FpY2liZXo0eExBLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png)

IP协议.png

### 6、接收并解析请求报文后回传响应报文

![服务器接收及解析请求报文后回传响应报文.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljSng2bXB3VVJSMDRwdmQ3b2VBcTVDdTZOTmpEaWEwaWJjNnczbEpGSkhTQlRtNXZxSXV0TzZVNXcvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png)

服务器接收及解析请求报文后回传响应报文.png

接收端（服务器）响应报文同样利用TCP/IP通信协议回传

##四、TCP建立连接及断开（重点补充）

###TCP建立连接（3次握手）

TCP 提供面向有连接的通信传输，面向有连接是指在数据通信开始之前先做好两端之间的准备工作。 三次握手是指建立一个TCP连接时需要客户端和服务器端总共发送三个标记包以确认连接的建立。下面来看看三次握手的流程图：

![3次握手](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljbU55Rm40dHlxUGRESkRZQWljYTFVekdXb0lTUTY1NVphRWFBYlVtU3VHYlNVNXBQd1ZoMDRhdy82NDA_d3hfZm10PWpwZWc?x-oss-process=image/format,png)

3次握手

**第一次握手**：客户端将标志位**SYN置为1**，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。

**第二次握手**：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位**SYN和ACK都置为1**，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。

**第三次握手**：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位**ACK置为1**，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手建立连接，随后客户端与服务器端之间可以开始传输数据了。

**为什么3次握手**: 前两次的握手很显然是必须的，主要是最后一次，即客户端收到服务端发来的确认后为什么还要想服务端再发送一次确认呢？这主要是**为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判。**

考虑如下的情况： 客户端发送了一个连接请求报文段到服务端，但是在某些网络节点上长时间滞留了，所以客户端又超时重发了一个连接请求报文段该服务端，而后正常建立连接，数据传输完毕，并释放了连接。 如果这时候第一次发送的请求报文段（已过期的）延迟了一段时间后，又到了服务端，很显然，这本是一个早已失效的报文段，但是服务端收到后会误以为客户端又发出了一次连接请求，于是向客户端发出确认报文段，并同意建立连接。假设不采用三次握手，这时服务端只要发送了确认，新的连接就建立了。但由于客户端现阶段没有发出建立连接的请求，因此不会理会服务端的确认，也不会向服务端发送数据，而服务端却认为新的连接已经建立了，并在一直等待客户端发送数据，这样服务端就会一直等待下去，直到超出保活计数器的设定值，而将客户端判定为出了问题，才会关闭这个连接。这样就浪费了很多服务器的资源。而如果采用三次握手，客户端没有再向服务端发出确认，服务端由于收不到确认，就知道客户端没有要求建立连接，从而不建立该连接。

### TCP断开连接（4次挥手）

TCP连接是全双工的，因此，每个方向都必须要单独进行关闭， 四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。 下面来看看四次挥手的流程图：

![4次挥手](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9KZExrRUk5c1pmZTBDSVlBaWNwRHBTUWttR2FHVmliTHljQmxaZ2ljSjJpYmRvWmt2RXByS2VOdVNTc2plNU1pYzlFcEZpYUo1c1FBQXFpYnIxS2Z4bWF6cXpJaWNnLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png)

4次挥手

注：中断连接端可以是客户端，也可以是服务器端。下文举的例子是以客户端发出中断请求。

**第一次挥手**：客户端发送一个**FIN=M**，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

**第二次挥手**：服务器端收到FIN后，先发送**ack=M+1**，告诉客户端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息。”这个时候客户端就进入FIN_WAIT_2状态，继续等待服务器端的FIN报文。

**第三次挥手**：当服务器端确定数据已发送完成，则向客户端发送**FIN=N**报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。

**第四次挥手**：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送**ACK=1，ack=N+1**后进入TIME_WAIT状态，如果服务器端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了（CLOSED状态）。客户端等待了2MSL（时间MSL叫做最长报文寿命，RFC建议设为2分钟）后依然没有收到回复，则证明服务器端已正常关闭，客户端也可以关闭连接了。最终完成了四次握手。

**为什么4次挥手**：TCP协议是一种面向连接的、可靠的字节流的运输层通信协议，TCP是全双工模式，这就意味着，当客户端发出FIN报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；但是，这个时候客户端还是可以接受来自服务器的数据；当服务器返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是主机2还是可以发送数据到客户端的；当服务器也发送了FIN报文段时，这个时候就表示服务器也没有数据要发送了，就会告诉客户端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

**为什么客户端TIME_WAIT等待2MSL**： 

（1）**为了保证客户端发送的最后一个ACK报文段能够到达服务器**。该ACK报文段很有可能丢失，因而使处于在LIST—ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认，服务器可能会重传这个FIN+ACK报文段，而客户端就在这2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务器都进入CLOSED状态。

（2）**防止已失效的请求连接出现在本连接中**。在连接处于2MSL等待时，任何迟到的报文段将被丢弃，因为处于2MSL等待的，由该插口（插口是IP和端口对的意思，socket）定义的连接在这段时间内将不能被再用，这样就可以使下一个新的连接中不会出现这种旧的连接之前延迟的报文段。



# HTTP入门

## 1. 为什么要学HTTP？

我们绝大多数的Web应用都是基于HTTP来进行开发的。我们对Web的操作都是通过HTTP协议来进行传输数据的。

简单来说，**HTTP协议就是客户端和服务器交互的一种通迅的格式**。

HTTP的诞生主要是为了能够**让文档之间相互关联，形成超文本可以互相传阅**

可以说，Http就是Web通信的基础，这是我们必学的。

## 2. HTTP基础概念

我们学计算机网络的时候就知道，我们把计算机网络分层了5层，一般我们现在用的都是TCP/IP这么一个分层结构。

虽然官方的是ISO 提出的7层结构，但是仅仅是理论基础，在实际上大多人都是使用TCP/IP的分层结构

首先，我们先得知道，为什么我们要在计算机网络中分层次？？？

因为如果两台计算机能够相互通信的话，实际实现起来是非常困难操作的...我们**分层的目的就是为了将困难的问题简单化**，并且如果我们分层了，我们在使用的时候就可**以仅仅关注我们需要关注的层次，而不用理会其他层**。

如果需要改动设计的时候，我们只需要把变动的层替换即可，并不用涉及到其他的层次。这与我们程序设计中的低耦合是一个概念。

**而我们的HTTP协议是在最上层，也就是应用层**。这是最贴近我们的程序员的层次。

## 3.网站通信粗略过程

我们知道HTTP是在应用层中的，显然，**我们在Web通信的过程中，不仅仅是需要HTTP协议的，还会涉及到其他的协议的**。

**DNS：负责解析域名**

- 我们访问一个网页的时候，往往是通过域名来访问的`www.zhongfucheng.site`,而计算机通信只认的是我们的主机地址(192.168.xxx.xxx)，因此，当我们输入域名的时候，需要DNS把域名解析成主机来进行访问。

**HTTP：产生请求报文数据**

- 当我们对Web页面进行操作的时候，就会产生HTTP报文数据，请求对应的服务端进行响应。

![这里写图片描述](https://user-gold-cdn.xitu.io/2018/2/6/1616ac76886fe048?w=1165&h=567&f=png&s=72565)

**TCP协议：分割HTTP数据，保证数据运输**

- TCP协议**采用了三次握手的方式来保证数据的准确运输**，在运输的数据的时候，发送标识过去给服务器，服务器也返回标识给客户端，而客户端收到消息后再次返回标识给服务器。这样一来就保证了数据运输是可靠的。

**IP协议：传输数据包，找到通信目的地地址。**

- IP协议把我们的产生的数据包发送给对方，IP地址指明了节点被分配的地址，但IP地址可能会变换，**我们可以使用ARP协议来将IP地址反射为MAC地址**。MAC地址是不会更改的，是网卡所属的固定地址。
- 在找到通信目的地之前，**我们是需要不断的中转的，这过程我们称作为：“路由中转”**，我们并不知道路由中转了多少次的。因此是不能全面了解到互联网中的传输状况的。

接下来就离我们比较远了，属于硬件相关的了，也就是链路层和物理层。以后复习到计算机网络的时候再来补充吧！

**我们网页上请求数据就是上边这么一个流程**。

## 4. 告知服务器请求的意图

我们如果开发过Web程序的话，我们知道常用的提交方式有POST和GET方法

我们也知道GET是用来获取数据的，POST是用来提交数据的。

其实HTTP协议中还支持着其他的方法，比如：Input、Delete、OPTIONS很多这样的方法。而由于常用，于是我们也可能仅仅知道GET和POST方法了。

**HTTP提供方法的目的就是为了告知服务器该客户端想进行什么操作**。当HTTP是OPTIONS方法的时候，服务器端就会返回它支持什么HTTP方法。

当然了，**现在RESTful盛行，也就是充分利用了HTTP协议的这些方法**。

## 5. HTTP是不保存状态的协议

HTTP是无状态的，也就是说，**它是不对通信状态进行保存的。它并不知道之前通信的对方是谁**。这样设计的目的就是为了让HTTP简单化，能够快速处理大量的事务！

但是，我们经常是需要知道访问的人是谁，于是就有了Cookie技术了。

- 要是服务器端想要记住客户端是谁，那么就颁发一个cookie给客户端
- 客户端把Cookie保存在硬盘中，当下次访问服务器的时候，浏览器会自动把客户端的cookie带过去。
- 就这样，服务器就能够知道这家伙是谁了。

## 6.持久连接

在HTTP1.0的时候，每一次进行HTTP通信就会断开一次连接。如果容量很少的文本传输是没有问题的。但是如果我们访问一个网页，该网页有非常多的图片。一个图片就算上一个HTTP请求了。那么在中途中就不断地建立TCP连接、获取图片、断开TCP连接。

这样是非常浪费资源的，因此在HTTP1.1版本，就是持久连接了。**一次HTTP连接能够处理多个请求**。

持久连接为“管线化”方式发送成为了可能：**在一次HTTP连接里面，不需要等待服务器响应请求，就能够继续发送第二次请求**。

## 7.提升传输效率

在说明之前，首先我们要知道什么是实体主体

- **实体主体就是作为数据在HTTP中传输的数据**。

一般地，**实体主体可以等价为报文主体，报文主体是HTTP中的一部分**。

我们如果不使用任何手段，服务器返回的数据实体主体是原样返回的。我们可以使用两种方式来提高传输效率

- **使用压缩技术把实体主体压小，在客户端再把数据解析**
- **使用分块传输编码，将实体主体分块传输，当浏览器解析到实体主体就能够显示了。**

我们如果在下载东西的过程中断了，按照以前我们是需要重新下载的，但是现在可以在中断中继续下载。我们可以**使用到获取范围数据，这种叫做范围请求**！

这种请求只会下载资源的一部分。

- 比如我的图片下载到一半了，我们只需要下载另一半就可以组成一张完整的图片了。那么**请求的时候请求没有下载的一部分即可。**

## 8.常用的状态码简述

### 2XX

一般是请求成功

200 正常处理

204 成功处理，但服务器没有新数据返回，显示页面不更新

206 对服务器进行范围请求，只返回一部分数据

### 3XX

一般表示重定向

301 请求的资源已分配了新的URI中，URL地址改变了。【永久重定向】

302 请求的资源临时分配了新的URI中，URL地址没变【临时重定向】

303 与302相同的功能，但明确客户端应该采用GET方式来获取资源

304 发送了附带请求，但不符合条件【返回未过期的缓存数据】

307 与302相同，但不会把POST请求变成GET

### 4XX

表示客户端出错了。

400 请求报文语法错误了

401 需要认证身份

403 没有权限访问

404 服务器没有这个资源

### 5XX

服务器出错了

500 内部资源出错了

503 服务器正忙

## 9.服务器与客户端之间的应用程序

首先要说的是，一个HTTP服务器可以拥有多个站点，也就是说：**HTTP下可以配置多个虚拟主机。当用户访问不同主机的时候，实际上都是访问同一台HTTP服务器。**

在客户端和服务器中还有一些用于**通信数据转发的应用程序**：

- 代理
  - 可以用来缓存数据，当代理缓存了数据以后，客户端就可以直接用代理获取数据
  - 可以用来对网站进行访问控制，获取访问日志记录
- 网关
  - 能够提供非HTTP请求的操作，访问数据库什么的
- 隧道
  - 建立一条安全的通信路径，可以使用SSL等加密手段进行通信。

## 10. HTTP首部简述

### 10.1 HTTP请求报文

HTTP请求报文：在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分组成。

![img](https://user-gold-cdn.xitu.io/2018/2/6/1616ac768892bd66?w=735&h=272&f=png&s=109239)

1. 请求行【描述客户端的**请求方式**、**请求的资源名称**，以及使用的**HTTP协议版本号**】
2. 首部字段【描述客户端请求哪台主机，以及**客户端的一些环境信息**等】
3. 一个空行

**首部字段例子：**

- Accept: text/html,image/*    【浏览器告诉服务器，它支持的数据类型】

- Accept-Charset: ISO-8859-1	【浏览器告诉服务器，它支持哪种**字符集**】

- Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的**压缩格式**】

- Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】

- Host: [www.it315.org:80](www.it315.org:80)【浏览器告诉服务器，它的想访问哪台主机】

- If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】

- Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---**反盗链**】

- 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】

- Cookie【浏览器告诉服务器，**带来的Cookie是什么**】

- Connection: close/Keep-Alive  【浏览器告诉服务器，请求完后是断开链接还是保持链接】 

- Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】 

  

  

### 10.2 HTTP响应报文

  HTTP响应报文：在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分组成。 

  ![img](https://user-gold-cdn.xitu.io/2018/2/6/1616ac7688c9b6a3?w=724&h=260&f=png&s=100825)

    1. 一个状态行【用于描述**服务器对请求的处理结果。**】
    2. 首部字段【用于描述**服务器的基本信息**，以及**数据的描述**，**服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据**】
    3. 一个空行
    4. 实体内容【**服务器向客户端回送的数据**】

   




  **状态行：**

  - 格式： HTTP版本号　状态码　原因叙述
  - 状态行：HTTP/1.1  200    OK
  - 状态码用于表示**服务器对请求的处理结果**，它是一个**三位的十进制数**。响应状态码分为5类 ![img](https://user-gold-cdn.xitu.io/2018/2/4/1615e7a4e770c043?w=993&h=290&f=png&s=18523)

  **首部字段例子：**

  - Location: http://www.it315.org/index.jsp 【服务器告诉浏览器**要跳转到哪个页面**】
  - Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】
  - Content-Encoding: gzip 【服务器告诉浏览器**数据压缩的格式**】
  - Content-Length: 80 【服务器告诉浏览器回送数据的长度】
  - Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】
  - Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，**回送数据的类型**】
  - Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】
  - Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要**定时刷新**】
  - Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器**以下载方式打开数据**】
  - Transfer-Encoding: chunked  【服务器告诉浏览器数据以分块方式回送】
  - Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要**保存Cookie**】
  - Expires: -1【服务器告诉浏览器**不要设置缓存**】
  - Cache-Control: no-cache  【服务器告诉浏览器**不要设置缓存**】
  - Pragma: no-cache   【服务器告诉浏览器**不要设置缓存**】
  - Connection: close/Keep-Alive   【服务器告诉浏览器连接方式】
  - Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】

## 11.HTTPS简述

HTTP在安全上是不足的

- 通信使用明文【没有加密过内容的】
- 不验证通信方身份，无论是客户端和服务器，都是随意通信的
- 无法证明报文的完整性【别人监听后，可以篡改】

我们一般在上网时，使用抓包工具就很容易获取到HTTP请求的信息了，这是TCP/IP在网络通信中无法避免的。

假设我们对HTTP报文进行加密了， 那也仅仅是是内容的加密。别人获取到了HTTP内容了，即使无法破解HTTP内容，还是能够篡改的。

我们最好就是**使用SSL建立安全的通信线路**，就可以在这条线路上进行HTTP通信了。

其实HTTPS就是披着SSL的HTTP...

HTTPS使用的是共享密钥和公开私有密钥混合来进行加密的。由于公开私有密钥需要太多的资源，不可能一直以公开私有密钥进行通信。因此，**HTTP在建立通信线路的时候使用公开私有密钥，当建立完连接后，随后就使用共享密钥进行加密和解密了**

对于认证方面，HTTPS是**基于第三方的认证机构来获取认受认可的证书**、因此，可以从认证该服务器是否是合法的。

而客户端方面则需要自己购买认证证书、这实施起来难度是很大的【认证证书需要钱】。

所以，一般的网站都是使用表单认证就算了，这是用得最广泛的客户端认证了。



# HTTP/2 && HTTPS

## 1. HTTP协议的今生来世

到现在为止，HTTP协议已经有四个版本了：

- HTTP1.0
- HTTP1.1
- HTTP/2
- HTTP/3

下面就简单聊聊他们三者的区别，以及整理一些必要的额外知识点。

(HTTP/3暂不聊，有兴趣的可以去搜搜）

### 1.1 HTTP1.0和HTTP1.1区别

HTTP1.0和HTTP1.1最主要的区别就是：

- HTTP1.1默认是**持久化连接**！

在HTTP1.0默认是短连接：

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef42a864451?w=944&h=285&f=png&s=68970)

简单来说就是：**每次与服务器交互，都需要新开一个连接**！

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef4311d5d2c?w=505&h=541&f=png&s=225252)

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef42a4c5f1a?w=600&h=316&f=png&s=142626)

试想一下：请求一张图片，新开一个连接，请求一个CSS文件，新开一个连接，请求一个JS文件，新开一个连接。HTTP协议是基于TCP的，TCP每次都要经过**三次握手，四次挥手，慢启动**...这都需要去消耗我们非常多的资源的！

在HTTP1.1中默认就使用持久化连接来解决：**建立一次连接，多次请求均由这个连接完成**！(如果阻塞了，还是会开新的TCP连接的)

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef42a5e594a?w=932&h=244&f=png&s=39891)

 

相对于持久化连接还有另外比较重要的改动：

- HTTP 1.1增加host字段
- HTTP 1.1中引入了`Chunked transfer-coding`，范围请求，实现断点续传(实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输)
- HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应之后再请求
  - 注意：这个pipelining仅仅是**限于理论场景下**，大部分桌面浏览器仍然会**选择默认关闭**HTTP pipelining！
  - 所以现在使用HTTP1.1协议的应用，都是有**可能会开多个TCP连接**的！

参考资料：https://www.cnblogs.com/gofighting/p/5421890.html

### 1.2 HTTP2基础

在说HTTP2之前，不如先直观比较一下HTTP2和HTTP1.1的区别：

- https://http2.akamai.com/demo

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef4395f4f75?w=1168&h=678&f=gif&s=818066)

上面也已经说了，HTTP 1.1提出了管线化(pipelining)理论，但是仅仅是限于理论的阶段上，这个功能默认还是关闭了的。

管线化(pipelining)和非管线化的**区别**：

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef42a2e5dd6?w=360&h=224&f=jpeg&s=13696)

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef54ecd3300?w=735&h=372&f=png&s=131986)

> HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，**客户端还是要按照发送请求的顺序来接收响应！**

------

> 就像在超市收银台或者银行柜台排队时一样，你并不知道前面的**顾客**是干脆利索的还是会跟收银员/柜员磨蹭到世界末日（不管怎么说，服务器（即收银员/柜员）是要按照顺序处理请求的，如果**前一个请求非常耗时（顾客磨蹭）**，那么后续请求都会受到影响。

 

- 在HTTP1.0中，发送一次请求时，需要**等待服务端响应了**才可以继续发送请求。
- 在HTTP1.1中，发送一次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照**响应的顺序**来一一接收
- 所以说，无论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现**阻塞**的情况。从专业的名词上说这种情况，叫做**线头阻塞**（Head of line blocking）简称：HOLB

### 1.3 HTTP1.1和HTTP2区别

HTTP2与HTTP1.1最重要的区别就是**解决了线头阻塞的**问题！其中最重要的改动是：**多路复用 (Multiplexing)**

- 多路复用意味着线头阻塞将不在是一个问题，允许同时通过单一的 HTTP/2 连接发起**多重的请求-响应消息**，合并多个请求为一个的优化将不再适用。
  - (我们知道：HTTP1.1中的Pipelining是没有付诸于实际的)，之前为了**减少**HTTP请求，有很多操作将多个请求合并，比如：Spriting(多个图片合成一个图片)，内联Inlining(将图片的原始数据嵌入在CSS文件里面的URL里），拼接Concatenation(一个请求就将其下载完多个JS文件)，分片Sharding(将请求分配到各个主机上)......

使用了HTTP2可能是这样子的：

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef547ad1464?w=605&h=468&f=png&s=201452)

 

HTTP2所有性能增强的核心在于**新的二进制分帧层**(不再以文本格式来传输了)，它定义了如何封装http消息并在客户端与服务器之间传输。

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef59a266e62?w=910&h=774&f=png&s=46892)

看上去协议的格式和HTTP1.x完全不同了，**实际上HTTP2并没有改变HTTP1.x的语义**，只是把原来HTTP1.x的header和body部分用**frame重新封装了一层**而已

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef56ba56ba1?w=720&h=378&f=png&s=58160)

HTTP2连接上**传输的每个帧都关联到一个“流”**。流是一个独立的，双向的帧序列可以通过一个HTTP2的连接在服务端与客户端之间不断的交换数据。

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef56e3a513e?w=644&h=381&f=png&s=54085)

实际上运输时：

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef6f61bb592?w=644&h=170&f=png&s=61246)

HTTP2还有一些比较重要的改动：

- 使用HPACK对HTTP/2头部压缩
- 服务器推送
  - HTTP2推送资料：https://segmentfault.com/a/1190000015773338
- 流量控制
  - 针对传输中的**流**进行控制(TCP默认的粒度是针对连接)
- 流优先级（Stream Priority）它被用来告诉**对端哪个流更重要**。

## 2.2 HTTP2总结

HTTP1.1新改动：

- **持久连接**
- 请求管道化
- 增加缓存处理（新的字段如cache-control）
- 增加Host字段、支持断点传输等

HTTP2新改动：

- 二进制分帧
- **多路复用**
- 头部压缩
- 服务器推送

 

## 2.3HTTPS再次回顾

之前在面试的时候被问到了HTTPS，SSL这样的知识点，也没答上来，这里也简单整理一下。

首先还是来解释一下基础的东东：

- 对称加密：
  - 加密和解密都是用同一个密钥
- 非对称加密：
  - 加密用公开的密钥，解密用私钥
  - (私钥只有自己知道，公开的密钥大家都知道)
- 数字签名：
  - 验证传输的内容**是对方发送的数据**
  - 发送的数据**没有被篡改过**
- 数字证书（Certificate Authority）简称CA
  - 认证机构证明是**真实的服务器发送的数据**。

3y的通讯之路：

- 远古时代：3y和女朋友聊天传输数据之间没有任何的加密，直接传输
  - 内容被看得一清二楚，毫无隐私可言
- 上古时期：使用对称加密的方式来保证传输的数据只有两个人知道
  - 此时有个问题：**密钥不能通过网络传输**(因为没有加密之前，都是不安全的)，所以3y和女朋友先约见面一次，告诉对方密码是多少，再对话聊天。
- 中古时期：3y不单单要跟女朋友聊天，还要跟爸妈聊天的哇(同样不想泄漏了自己的通讯信息)。那有那么多人，难道每一次都要约来见面一次吗？(说明维护多个对称密钥是麻烦的！)--->所以用到了非对称加密
  - 3y自己保留一份密码，独一无二的(私钥)。告诉3y女朋友，爸妈一份密码(这份密码是公开的，谁都可以拿--->公钥)。让他们给我发消息之前，先用那份我告诉他们的密码加密一下，再发送给我。我收到信息之后，用自己独一无二的私钥解密就可以了！
- 近代：此时又出现一个问题：虽然别人不知道私钥是什么，拿不到你**原始传输**的数据，但是可以拿到加密后的数据，他们可以**改掉**某部分的数据再发送给服务器，这样服务器拿到的数据就**不是完整的**了。
- 现代：拿到的数据可能被篡改了，我们可以使用数字签名来解决被篡改的问题。数字签名其实也可以看做是**非对称加密的手段一种**，具体是这样的：得到原信息hash值，用**私钥**对hash值加密，**另一端**用**公钥**解密，最后比对hash值是否变了。如果变了就说明被篡改了。(一端用私钥加密，另一端用公钥解密，也确保了来源)
- 目前现在：好像使用了数字签名就万无一失了，其实还有问题。我们使用非对称加密的时候，是使用**公钥进行加密的**。如果**公钥被伪造了**，后面的数字签名其实就毫无意义了。讲到底：**还是可能会被中间人攻击**~此时我们就有了**CA认证机构来确认公钥的真实性**！

对于数字签名和CA认证还是不太了解参考一下

- 阮一峰：http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html
- 什么是数字签名和证书？https://www.jianshu.com/p/9db57e761255

------

回到我们的HTTPS，HTTPS其实就是在HTTP协议下多加了一层SSL协议(ps:现在都用TLS协议了)

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef6f19089b3?w=753&h=357&f=png&s=72644)

HTTPS采用的是**混合方式加密**：

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef6f887edd2?w=716&h=641&f=png&s=178969)

过程是这样子的：

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef6f890c6ea?w=828&h=686&f=png&s=310032)

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef684f2cad9?w=853&h=561&f=png&s=283962)

- 用户向web服务器发起一个安全连接的请求
- 服务器返回经过CA认证的数字证书，证书里面包含了服务器的public key(公钥)
- 用户拿到数字证书，用自己浏览器内置的CA证书解密得到服务器的public key
- 用户用服务器的public key加密一个用于接下来的对称加密算法的密钥，传给web服务器
  - 因为只有服务器有private key可以解密，所以**不用担心中间人拦截这个加密的密钥**
- 服务器拿到这个加密的密钥，解密获取密钥，再使用对称加密算法，和用户完成接下来的网络通信

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef6b98d8a82?w=567&h=362&f=png&s=80543)

所以相比HTTP，HTTPS 传输更加安全

- （1） 所有信息都是加密传播，黑客无法窃听。
- （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。
- （3） 配备身份证书，防止身份被冒充。

参考资料：

- 数字签名、数字证书、SSL、https是什么关系？https://www.zhihu.com/question/52493697/answer/131015846
- 浅谈SSL/TLS工作原理：https://zhuanlan.zhihu.com/p/36981565
- HTTPS:[https://tech.upyun.com/article/192/HTTPS%E7%B3%BB%E5%88%97%E5%B9%B2%E8%B4%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTTPS%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.html](https://tech.upyun.com/article/192/HTTPS系列干货（一）：HTTPS 原理详解.html)
- 网站HTTP升级HTTPS完全配置手册：https://www.cnblogs.com/powertoolsteam/p/http2https.html



 







# HTTP常见面试题

## 1.Http与Https的区别：

> Http与Https的区别：

1. HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
2. HTTP 是不安全的，而 HTTPS 是安全的
3. HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
4. 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
5. HTTP 无法加密，而HTTPS 对传输的数据进行加密
6. HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书

 

## 2. 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

- **无状态协议对于事务处理没有记忆能力**。**缺少状态意味着如果后续处理需要前面的信息**
  - **也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。**
- **可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候服务器给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。**

 

## 3.URI和URL的区别

> URI和URL的区别

**URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。**

- Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
- URI一般由三部组成：
- ①访问资源的命名机制
- ②存放资源的主机名
- ③资源自身的名称，由路径表示，着重强调于资源。

**URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。**

- URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
- 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
- ①协议(或称为服务方式)
- ②存有该资源的主机IP地址(有时也包括端口号)
- ③主机资源的具体地址。如目录和文件名等

**URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如[mailto:java-net@java.sun.com](mailto:mailto:java-net@java.sun.com)。**

- URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。

在Java的URI中，**一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。**

**在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。**

**相反的是，URL类可以打开一个到达资源的流。**

## 4. 常用的HTTP方法有哪些？

> 常用的HTTP方法有哪些?

- GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

 

## 5. HTTP请求报文与响应报文格式

> HTTP请求报文与响应报文格式

请求报文包含四部分：

- a、请求行：包含请求方法、URI、HTTP版本信息
- b、请求首部字段
- c、请求内容实体
- d、空行

响应报文包含四部分：

- a、状态行：包含HTTP版本、状态码、状态码的原因短语
- b、响应首部字段
- c、响应内容实体
- d、空行

常见的首部：

- **通用首部字段（请求报文与响应报文都会使用的首部字段）**
  - Date：创建报文时间
  - Connection：连接的管理
  - Cache-Control：缓存的控制
  - Transfer-Encoding：报文主体的传输编码方式
- **请求首部字段（请求报文会使用的首部字段）**
  - Host：请求资源所在服务器
  - Accept：可处理的媒体类型
  - Accept-Charset：可接收的字符集
  - Accept-Encoding：可接受的内容编码
  - Accept-Language：可接受的自然语言
- **响应首部字段（响应报文会使用的首部字段）**
  - Accept-Ranges：可接受的字节范围
  - Location：令客户端重新定向到的URI
  - Server：HTTP服务器的安装信息
- **实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）**
  - Allow：资源可支持的HTTP方法
  - Content-Type：实体主类的类型
  - Content-Encoding：实体主体适用的编码方式
  - Content-Language：实体主体的自然语言
  - Content-Length：实体主体的的字节数
  - Content-Range：实体主体的位置范围，一般用于发出部分请求时使用

## 6. HTTPS工作原理

> HTTPS工作原理

- 一、首先HTTP请求服务端获取证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；
- 二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；
- 三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；
- 四、发送给服务端，此时只有服务端（RSA私钥）能解密。
- 五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。

具体的参考链接：http://blog.csdn.net/sean_cd/article/details/6966130

## 6. 一次完整的HTTP请求所经历的7个步骤

> 一次完整的HTTP请求所经历的7个步骤

HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤： 

- 建立TCP连接

在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。**HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。**

- Web浏览器向Web服务器发送请求行

一旦建立了TCP连接，**Web浏览器就会向Web服务器发送请求命令**。例如：GET /sample/hello.jsp HTTP/1.1。

- Web浏览器发送请求头
  - 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，**之后浏览器发送了一空白行来通知服务器**，它已经结束了该头信息的发送。 
- Web服务器应答 
  - 客户机向服务器发出请求后，服务器会客户机回送应答， **HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。**
- Web服务器发送应答头
  - 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 
- Web服务器向浏览器发送数据 
  - Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，**它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据**。
- Web服务器关闭TCP连接 
  - 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：

 `Connection:keep-alive`

TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

建立TCP连接->发送请求行->发送请求头->（到达服务器）发送状态行->发送响应头->发送响应数据->断TCP连接

 

最具体的HTTP请求过程：http://blog.51cto.com/linux5588/1351007

## 7. 常见的HTTP相应状态码

> 常见的HTTP相应状态码

- 200：请求被正常处理
- 204：请求被受理但没有资源可以返回
- 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
- 301：永久性重定向
- 302：临时重定向
- 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
- 304：发送附带条件的请求时，条件不满足时返回，与重定向无关
- 307：临时重定向，与302类似，只是强制要求使用POST方法
- 400：请求报文语法有误，服务器无法识别
- 401：请求需要认证
- 403：请求的对应资源禁止被访问
- 404：服务器无法找到对应资源
- 500：服务器内部错误
- 503：服务器正忙

## 8. HTTP1.1版本新特性

> HTTP1.1版本新特性

- a、**默认持久连接节省通信量**，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求
- b、**管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应**
- c、**断点续传**
  - **实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。**

## 9. HTTP优化方案

我下面就简要概括一下：

- **TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能**
- **内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。**
- **压缩：将文本数据进行压缩，减少带宽**
- **SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速**
- **TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。**

详情参考：

- http://blog.51cto.com/virtualadc/580832 
- http://www.cnblogs.com/cocowool/archive/2011/08/22/2149929.html



# 计算机网络面试题

## 分层的概念

### 问题 1：OSI 有哪几层，会画出来，知道主要几层的各自作用
1. 应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用

2. 表示层（数据）：主要解决拥护信息的语法表示问题，如加密解密

3. 会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机
  制，如服务器验证用户登录便是由会话层完成的

4. 传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠
  与不可靠的传输，传输层的错误检测，流量控制等

5. 网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的
  传输

6. 数据链路层（帧）：将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正

7. 物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等
  

  

### 问题2：知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关）

1. 网关：应用层、传输层（网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连）

2. 路由器：网络层（路由选择、存储转发）

3. 交换机：数据链路层、网络层（识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中）

4. 网桥：数据链路层（将两个 LAN 连起来，根据 MAC 地址来转发帧）

5. 集线器（Hub）：物理层（纯硬件设备，主要用来连接计算机等网络终端）

6. 中继器：物理层（在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离）

## **数据链路层**

### **ARP** **协议**

**问题 1：ARP 的作用？**

ARP 为 IP 地址到对应的硬件地址提供动态映射。

**问题 2：点对点链路使用 ARP 吗？**

不使用

**问题 3：ARP 高效运行的关键是什么？**

关键是每个主机上都有一个 ARP 的高速缓存。

**问题 4：ARP 报文的各个字段以及含义？**

帧类型：ARP：0x0806 （2） 

ARP 首部：

硬件类型：硬件地址的类型，1 表示以太网地址。（2）

协议类型：协议地址的类型，0x0800 表示 IP 地址。(2)

硬件地址长度：字节为单位 6 （1）

协议地址长度：字节为单位 4 (1)

操作类型：2 个字节。 ARP 请求 1，ARP 回复 2，RARP 请求 3，RARP 应答 4。（2）

发送者硬件地址：6 个字节（6）

发送者 IP 地址：4 个字节（4）

目标硬件地址：6 个字节（6）

目标 IP 地址：4 个字节（4）

CRC 校验：4 个字节 （4）

总结：

arp 总共 28 个字节。

记忆方法： 以太网先目地后源，ARP 先发送端后目地端。先硬件后协议。

**问题 5：ARP 协议有什么弱点？**

1）缓存：主机的地址映射是基于高速缓存的，动态更新的。地址刷新是有时间限制的。 可

以通过下次更新之前修改计算机上的地址缓存，造成拒绝服务攻击或者 ARP 欺骗。

2）广播: 攻击者可以伪装 ARP 应答。

3）ARP 应答没有认证，都是合法的。可以在不接受到请求的时候就发出应答包。

**问题 6：ARP 代理的概念和应用场景**

若 ARP 请求是从一个网络的主机发送给另一个网络上的主机，那么连接这两个网络的路由

器就可以回答该请求，这个过程叫做 ARP 代理。ARP 代理路由器响应 ARP 请求的 MAC 地

址为路由器的 MAC 地址而非 ARP 请求的主机的 MAC 地址。

ARP 代理的应用环境：

两个物理网络之间的路由是使用相同的网络号，两个路由器设置成 ARP 代理，实现相互隐

瞒物理网络**问题 **

**7：免费 ARP**

指主机发送 ARP 查找自己的 IP 地址，即数据链路层 SIP=DIP

作用有两个：

1）一个主机使用免费 ARP 确定是有存在有其他主机设置了相同的 IP 地址

2）如果发送免费 ARP 的主机改变了 MAC 地址，可以通过发送免费 ARP 的方式告知其他

主机端更新 ARP 表

**问题 8：数据链路层 MTU 的最大值和最小值是多少？**

1) 数据链路层的**最小MTU 为 64 字节**。对于 IEEE802.3，两个站点的最远距离不超过 2500m， 

由 4 个中继器连接而成，其冲突窗口为 51.2us(2 倍电缆传播延迟加上 4 个中继器的双向延

迟).对于 10Mbps 的 IEEE802.3 来说，这个时间等于发送 64 字节，即 512 位的时间，64 字

节就是由此而来的。如果一个站点已经传输了 512bit，就认为它已经占用了这个信道。

2) 数据链路层的**最大 MTU 为 1500 字节**，即数据字段的最大长度

## **网络层**

**IP** **协议**

**问题 1：如何理解 IP 的不可靠和无连接。**

**不可靠**：指的是不能保证数据报能成功地到达目的地。

​		发生错误时候，丢弃该数据包，发送 ICMP 消息给信源端。 可靠性由上层提供。

**无连接**：IP 不维护关于后续数据报的状态信息。

​	体现在，IP 数据可以不按顺序发送和接收。A 发送连续的数据报，到达 B 不一定是连续的，来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。

**问题 2：IP 报文的格式和各个字段的含义。**

**版本号**： IPV4 就是 4，IPV6 就是 6 （4）

**首部长度**：4 个字节为单位。最小为 5，最大为 15。所以最小长度 20 个字节，最大为 60

个字节。（4）**服务类型**： Qos 用，目前不怎么使用。（8）

**总长度**：字节为单位。 最多可以传送 65535 字节的 IP 数据包。（16）

**标识字段**（8）

**标志** （3）

**段偏移**（5）与分片有关。

**生存时间 TTL**：经过一个路由器减一。 字段为 0 时，数据报被丢弃，并且发送 ICMP 报文

通知源主机。目的是防止数据报在选路时无休止地在网络中流动。（8）

**协议**：区分上层协议 （8）

**首部校验和**：仅对首部进行校验。（16）【对比： ICMP，IGMP，TCP，UDP：对首部和数

据进行校验】

**源地址**：（32）

**目的地址**：(32)

**问题 3：为什么 IP 首部中要有总长度字段？**

因为一些数据链路（以太网）需要填充一些数据以达到最小长度。因为以太网帧的最小长度

是 46 个字节，但是 IP 长度可能更短，所以需要总长度来确定 IP 数据部分的内容。

**问题 4：IP 首部校验和怎么计算的，与 ICMP，IGMP，TCP，UDP 的首部校验和有什么区**

**别与共同点？** 

（1） 先把校验和字段置 0。 

（2） 对首部中每个 16 位比特进行二进制反码求和。

（3） 结果存在检验和字段中。

（4） 收到一份 IP 数据包后，同样对首部中每个 16bit 二进制反码求和。

（5） 最后结果全为 1，表示正确，否则表示错误。

（6） 如果是错误的，IP 就丢弃该数据报，但是不生成差错报文，由上层去处理。

共同点：用到的算法都是一样的。

区别：IP 计算的时候没有将数据包括在内。

ICMP，IGMP，TCP，UDP 同时覆盖首部和数据检验码。

**问题 5：主机和路由器本质区别是？**

主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报。

**问题 6：IP 路由选择的过程是怎么样的？**

根据最长匹配原则，找到条目，发送到指定的路由器。如果不能找到，返回一个“主机不可

达”或“网络不可达”的错误。

**问题 7：IP 路由选择的特性有什么？**

（１） IP 路由选择是逐跳进行的。

IP 并不知道到达任何目的的完整路径，只提供下一跳地址。

（２） 为一个网络指定一个路由器，而不是为每个主机指定一个路由器。

这样可以缩小路由表规模。**问题 8：IP 搜索路由表的步骤**

搜索匹配的主机地址 ----》搜索匹配的网络地址 ----》搜索默认选项

IP 层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。

**问题 9：如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？**

结果取决于该 IP 数据报是由主机产生的还是被转发的。

如果数据报是由本机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主

机不可达差错”或者是“网络不可达差错”。

如果是被转发的数据报，就给原始发送一份 ICMP 主机不可达的差错报文。

**问题 10：IP 地址的分类，如何划分的，及会计算各类地址支持的主机数**

\1. A 类地址：首位为 0，1.0.0.1~~126.255.255.254；主机号 24 位

\2. B 类地址：首位为 10，128.0.0.1~~191.255.255.254；主机号 16 位

\3. C 类地址：首位为 110，192.0.0.1~~223.255.255.254；主机号 8 位

\4. D 类地址（多播地址，也叫做组播地址）：首位为 1110，224.0.0.1~~239.255.255.254

\5. E 类地址：此类地址是保留地址，首位为 11110，240.0.0.1~~254.255.255.254

**ICMP** **协议**

**问题 1：ICMP 的层次和作用。**

ICMP 一般认为是在三层的。主要传递一些差错报文和其他需要注意的信息。

**问题 2：ICMP 报文的分类？**

ICMP 分为两类，一类是 ICMP 查询报文，另一类是 ICMP 差错报文。

**问题 3：ICMP 的主机不可达报文是在什么情况下发出的？**

三层设备（路由器）给该主机寻路时，没有找到相应路径，向源 IP 发回 ICMP 主机不可达

**问题 4：什么情况不会导致产生 ICMP 差错报文？**

1） ICMP 差错报文。

2） 目的地址是广播地址或者多播地址的 IP 数据报。

3） 链路层广播的数据报

4） 不是 IP 分片的第一片

5） 源地址不是单个主机的数据包。

**问题 5：ICMP 重定向差错报文是怎么来的，在何种场合出现？**

主机

|

|

——————————————————————

| | 

| |

R1 R2

1） 主机发送 IP 数据报给 R1，因为主机的默认路由指向的下一跳是 R1。 

2） R1 收到数据报并且检查它的路由表，发现 R2 是发送该数据报的下一跳。当他将数

据报发送给 R2 的时候，发现发送的接口与接受的端口是一样的，因此同时发送一

个 ICMP 重定向报文给主机。

3） R1 接受到 ICMP 重定向报文后，接下来的数据报就发送给 R2，而不再发送给 R1。

**问题 6：重定向报文有什么规则？**

重定向报文只能有路由器生成。

重定向报文是为主机而不是为路由器使用的。**问题 7：Ping 命令的具体过程是怎么样的？**

参考文章：《对于 Ping 的过程，你真的了解吗？》

https://mp.weixin.qq.com/s/DfQT3Vw2xaq60YIil-7Yxw

## **传输层**

**UDP** **协议**

**问题 1：UDP 和 TCP 的简单介绍。**

UDP 是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个 UDP 数

据报，并组装成一份待发送的 IP 数据报。

TCP 是面向流字符，应用程序产生的全体数据与真正发送的单个 IP 数据报可能没什么联系。

**问题 2：UDP 报头字段和含义？**

源端口号（2）

目地端口号（2）

UDP 长度：是 UDP 的报文总长度，是多于的。 IP 总长度减去首部长度就是此值。（2）

UDP 校验和：注意点：校验和是可选的。 （TCP 是必选的）校验和覆盖 UDP 首部和数据

（TCP 也一样覆盖首部和数据，但是 IP 指覆盖首部）（2）**问题 3： UDP 的校验和是怎么计算的？**

UDP 的校验和要计算首部和数据部分。首部还包括伪首部。

多了 12 个字节的伪首部。

注意点：UDP 长度计算两次。

如果检验和有错，则 UDP 数据报被悄悄丢弃，不产生任何差错报文。

**问题 4：为什么要加有伪首部？**

目的是让 UDP 两次检查数据是否已经正确到达目的地。

IP 接受正确的目的地址，传送到正确的上层程序。

所有伪首部包括：源 IP 地址，目的 IP 地址，0，协议号，UDP 长度。

**TCP** **协议**

**问题 1：TCP 通过哪些方式来保证可靠性？**

1） 应用数据被分割成 TCP 认为最适合发送的数据块。

2） 确认机制，发送报文后，等待确认。

3） 重发机制，没有收到确认，将重发数据段。

4） 保持它首部和数据的校验和。确认数据的准确性。

5） 排序，丢弃重复的，流量控制。

**问题 2：TCP 与 UDP 的概念相互的区别及优劣**

\1. TCP 面向连接，UDP 面向无链接

\2. TCP 面向报文，UDP 面向字节流

\3. TCP 提供可靠传输服务（数据顺序、正确性），UDP 传输不可靠

\4. TCP 协议传输速度慢，UDP 协议传输速度快

\5. TCP 协议对系统资源要求多（头部开销大），UDP 协议要求少**问题 3：TCP、UDP 为什么存在伪包头？**

UDP(TCP)检验和：是根据 UDP(TCP)数据报和伪报头计算得到的差错检测值。

伪报头包含源和目的 IP 地址，以及来自 IP 数据报报头的协议值。IP 数据报在网络中传送时

包含 UDP 数据报。

伪报头并不会在网络中传送，校验和中所包含的伪报头内容可以避免目的端错误地接收错误

路由的数据报。校验和值的计算方法和 IP 报头检验和的计算方法类似

**问题 4：为什么要 3 次握手，4 次挥手**

\1. 3 次握手：防止已过期的连接请求报文突然又传送到服务器，因而产生错误

\2. 4 次挥手：确保数据能够完成传输，但关闭连接时，当收到对方的 FIN 报文通知时，它

仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以

未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文

给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下

都是分开发送的

**问题 5：TCP 的流量控制机制**

主要是下面的四种机制：

**慢启动（慢开始）：**

\1. 慢开始不是指 cwnd 的增长速度慢（指数增长），而是指 TCP 开始发送设置 cwnd=1。

\2. 思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大

逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时

拥塞窗口大小是以字节为单位的。

\3. 为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限（ssthresh 状态变量）

当 cnwd＜ssthresh，使用慢开始算法

当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法

当 cnwd＞ssthresh，使用拥塞避免算法

**拥塞避免：**

\1. 拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增

长，使网络比较不容易出现拥塞。

\2. 思路：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控

制窗口加一。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有

收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做

拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口

设置为 1，执行慢开始算法。 如图所示：

**快速重传：**

\1. 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及

早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发

送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设

置的重传计时器时间到期。

\2. 由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网

络的吞吐量。

**快速恢复：**

\1. 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。

但是接下去并不执行慢开始算法。

\2. 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络

可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，

然后执行拥塞避免算法。

## **应用层**

**问题 0：DNS 的概念，用途，DNS 查询的实现算法**

 概念

o 域名解析，www.xxx.com 转换成 ip，能够使用户更方便的访问互联网，而不

用去记住能够被机器直接读取的 ip 地址

o DNS 协议运行在 UDP 协议之上，使用端口号 53

 主机解析域名的顺序

o 浏览器缓存

o 找本机的 hosts 文件

o 路由缓存

o 找 DNS 服务器(本地域名、顶级域名、根域名) 

 迭代查询、递归查询

**问题 1：http 基本格式**

http 请求：http 响应：

**问题 2：GET、POST 区别**

**问题 3：Cookies 和 Session 的区别**

\1. **cookie** 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在

某个 WEB 站点会话间持久的保持数据

\2. **session** 其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session 其

实是利用 Cookie 进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器

上创建了一个 Cookie，当这个 Session 结束时，其实就是意味着这个 Cookie 就过期 

了

\3. cookie 数据保存在客户端，session 数据保存在服务器端

**问题 4：一次完整的 HTTP 请求所经历的步骤**

比如：在浏览器中输入 www.baidu.com 后执行的全部过程也可以参考文章：《抓包实战 | 浏览器里的 HTTP 请求到底是如何完成的？》

https://mp.weixin.qq.com/s/_fB7r53BGZRvpG9YAPRQ8A

**问题 5：http2.0 和 http1.1 的区别**



![image-20200423161238342](/Users/houshaojie/Library/Application Support/typora-user-images/image-20200423161238342.png)